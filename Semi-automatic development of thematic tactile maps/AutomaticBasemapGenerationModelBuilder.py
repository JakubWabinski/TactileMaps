# -*- coding: utf-8 -*-
"""
Generated by ArcGIS ModelBuilder on : 2022-04-13 13:43:21
Please bear in mind that the file has been automatically generated within ArcGIS ModelBuilder module. It might not work properly when directly loaded to the software. 
The script contains relative paths to the files that have been used in our case. They were hidden in the script. One has to properly indicate locations of the input data for the model to work properly.
"""
import arcpy

def FinalPipeline():  # Final pipeline

    # To allow overwriting outputs change overwriteOutput option to True.
    arcpy.env.overwriteOutput = False

    # Model Environment settings
    with arcpy.EnvManager(scratchWorkspace=r"RELATIVE PATH TO THE .gdb FILE"):
        Rivers_Projected_2_ = "RELATIVE PATH TO THE DATA FILE"
        Borders_Original = "RELATIVE PATH TO THE DATA FILE"
        Cities = "RELATIVE PATH TO THE DATA FILE"
        Thematic = "RELATIVE PATH TO THE DATA FILE"
        Water = "RELATIVE PATH TO THE DATA FILE"
        Water_3_ = "RELATIVE PATH TO THE DATA FILE"

        # Process: Convert lines to polygons for Select Layer By Location tool (Feature To Polygon) (management)
        Borders_Polygon = "RELATIVE PATH FOR THE OUTPUT DATA"
        arcpy.management.FeatureToPolygon(in_features=[Borders_Original], out_feature_class=Borders_Polygon, cluster_tolerance="", attributes="ATTRIBUTES", label_features="")

        # Process: Select rivers intersecting with Poland (Select Layer By Location) (management)
        Rivers_Projected, Output_Layer_Names, Count = arcpy.management.SelectLayerByLocation(in_layer=[Rivers_Projected_2_], overlap_type="INTERSECT", select_features=Borders_Polygon, search_distance="", selection_type="NEW_SELECTION", invert_spatial_relationship="NOT_INVERT")

        # Process: Select cities in Poland (Select Layer By Attribute) (management)
        Cities_Layer, Count_4_ = arcpy.management.SelectLayerByAttribute(in_layer_or_view=Cities, selection_type="NEW_SELECTION", where_clause="CNTRY_NAME = 'Poland'", invert_where_clause="")

        # Process: Copy_Cities (Copy Features) (management)
        Cities_Poland = "RELATIVE PATH FOR THE OUTPUT DATA"
        arcpy.management.CopyFeatures(in_features=Cities_Layer, out_feature_class=Cities_Poland, config_keyword="", spatial_grid_1=None, spatial_grid_2=None, spatial_grid_3=None)

        # Process: Copy_Rivers (Copy Features) (management)
        Rivers_Poland = "RELATIVE PATH FOR THE OUTPUT DATA"
        arcpy.management.CopyFeatures(in_features=Rivers_Projected, out_feature_class=Rivers_Poland, config_keyword="", spatial_grid_1=None, spatial_grid_2=None, spatial_grid_3=None)

        # Process: Select rivers longer than 100 km (Select Layer By Attribute) (management)
        Rivers_Projected_Long, Count_7_ = arcpy.management.SelectLayerByAttribute(in_layer_or_view=Rivers_Poland, selection_type="NEW_SELECTION", where_clause="Shape_Length > 100000", invert_where_clause="")

        # Process: Copy_Rivers (2) (Copy Features) (management)
        Rivers_Poland_Long = "RELATIVE PATH FOR THE OUTPUT DATA"
        arcpy.management.CopyFeatures(in_features=Rivers_Projected_Long, out_feature_class=Rivers_Poland_Long, config_keyword="", spatial_grid_1=None, spatial_grid_2=None, spatial_grid_3=None)

        # Process: Smooth_Line_Rivers (Smooth Line) (cartography)
        Rivers_Poland_SmoothLine = "RELATIVE PATH FOR THE OUTPUT DATA"
        with arcpy.EnvManager(transferGDBAttributeProperties=False):
            arcpy.cartography.SmoothLine(in_features=Rivers_Poland_Long, out_feature_class=Rivers_Poland_SmoothLine, algorithm="PAEK", tolerance="20000 Meters", endpoint_option="FIXED_CLOSED_ENDPOINT", error_option="FLAG_ERRORS", in_barriers=[])

        # Process: Snap cities to rivers that flow through them (Snap) (edit)
        Cities_Poland_Snap = arcpy.edit.Snap(in_features=Cities_Poland, snap_environment=[[Rivers_Poland_SmoothLine, "EDGE", "10000 Meters"]])[0]

        # Process: Select cities close to natural resources (below 20km) (Select Layer By Location) (management)
        Cities_Poland_Resources, Output_Layer_Names_2_, Count_2_ = arcpy.management.SelectLayerByLocation(in_layer=[Cities_Poland_Snap], overlap_type="WITHIN_A_DISTANCE_GEODESIC", select_features=Thematic, search_distance="20000 Meters", selection_type="NEW_SELECTION", invert_spatial_relationship="NOT_INVERT")

        # Process: Select cities with population > 200k (Select) (analysis)
        Cities_Poland_Major = "RELATIVE PATH FOR THE OUTPUT DATA"
        arcpy.analysis.Select(in_features=Cities_Poland_Snap, out_feature_class=Cities_Poland_Major, where_clause="POP > 200000")

        # Process: Merge major cities and those close to natural resources (Merge) (management)
        Cities_Selected_Merge = "RELATIVE PATH FOR THE OUTPUT DATA"
        arcpy.management.Merge(inputs=[Cities_Poland_Resources, Cities_Poland_Major], output=Cities_Selected_Merge, field_mappings="FID_1 \"FID_1\" true true false 2 Short 0 0,First,#,Cities_Poland_Layer1,FID_1,-1,-1,RELATIVE PATH FOR THE OUTPUT DATA,FID_1,-1,-1;OBJECTID \"OBJECTID\" true true false 2 Short 0 0,First,#,Cities_Poland_Layer1,OBJECTID,-1,-1,RELATIVE PATH FOR THE OUTPUT DATA,OBJECTID,-1,-1;CITY_NAME \"CITY_NAME\" true true false 29 Text 0 0,First,#,Cities_Poland_Layer1,CITY_NAME,0,29,RELATIVE PATH FOR THE OUTPUT DATA,CITY_NAME,0,29;GMI_ADMIN \"GMI_ADMIN\" true true false 7 Text 0 0,First,#,Cities_Poland_Layer1,GMI_ADMIN,0,7,RELATIVE PATH FOR THE OUTPUT DATA,GMI_ADMIN,0,7;ADMIN_NAME \"ADMIN_NAME\" true true false 41 Text 0 0,First,#,Cities_Poland_Layer1,ADMIN_NAME,0,41,"RELATIVE PATH FOR THE OUTPUT DATA",ADMIN_NAME,0,41;FIPS_CNTRY \"FIPS_CNTRY\" true true false 2 Text 0 0,First,#,Cities_Poland_Layer1,FIPS_CNTRY,0,2,"RELATIVE PATH FOR THE OUTPUT DATA",FIPS_CNTRY,0,2;CNTRY_NAME \"CNTRY_NAME\" true true false 28 Text 0 0,First,#,Cities_Poland_Layer1,CNTRY_NAME,0,28,"RELATIVE PATH FOR THE OUTPUT DATA",CNTRY_NAME,0,28;STATUS \"STATUS\" true true false 47 Text 0 0,First,#,Cities_Poland_Layer1,STATUS,0,47,"RELATIVE PATH FOR THE OUTPUT DATA",STATUS,0,47;POP \"POP\" true true false 4 Long 0 0,First,#,Cities_Poland_Layer1,POP,-1,-1,"RELATIVE PATH FOR THE OUTPUT DATA",POP,-1,-1;POP_RANK \"POP_RANK\" true true false 2 Short 0 0,First,#,Cities_Poland_Layer1,POP_RANK,-1,-1,"RELATIVE PATH FOR THE OUTPUT DATA",POP_RANK,-1,-1;POP_CLASS \"POP_CLASS\" true true false 22 Text 0 0,First,#,Cities_Poland_Layer1,POP_CLASS,0,22,"RELATIVE PATH FOR THE OUTPUT DATA",POP_CLASS,0,22;PORT_ID \"PORT_ID\" true true false 4 Long 0 0,First,#,Cities_Poland_Layer1,PORT_ID,-1,-1,"RELATIVE PATH FOR THE OUTPUT DATA",PORT_ID,-1,-1;LABEL_FLAG \"LABEL_FLAG\" true true false 2 Short 0 0,First,#,Cities_Poland_Layer1,LABEL_FLAG,-1,-1,"RELATIVE PATH FOR THE OUTPUT DATA",LABEL_FLAG,-1,-1;POP_SOURCE \"POP_SOURCE\" true true false 17 Text 0 0,First,#,Cities_Poland_Layer1,POP_SOURCE,0,17,"RELATIVE PATH FOR THE OUTPUT DATA",POP_SOURCE,0,17", add_source="NO_SOURCE_INFO")

        # Process: Delete Identical cities (overlapping) (Delete Identical) (management)
        FInal_Cities = arcpy.management.DeleteIdentical(in_dataset=Cities_Selected_Merge, fields=["FID_1"], xy_tolerance="", z_tolerance=0)[0]

        # Process: Clear selection before processing (Select Layer By Attribute) (management)
        Water_clear, Count_6_ = arcpy.management.SelectLayerByAttribute(in_layer_or_view=Water, selection_type="CLEAR_SELECTION", where_clause="", invert_where_clause="")

        # Process: Exclude running and sea water and small reservoirs (Select Layer By Attribute) (management)
        Water_selected, Count_3_ = arcpy.management.SelectLayerByAttribute(in_layer_or_view=Water_clear, selection_type="NEW_SELECTION", where_clause="x_kod = 'PTWP03' And Shape_Area > 20000000", invert_where_clause="")

        # Process: Copy_Water (Copy Features) (management)
        Water_reservoirs = "RELATIVE PATH FOR THE OUTPUT DATA"
        arcpy.management.CopyFeatures(in_features=Water_selected, out_feature_class=Water_reservoirs, config_keyword="", spatial_grid_1=None, spatial_grid_2=None, spatial_grid_3=None)

        # Process: Smooth Line - borders (Smooth Line) (cartography)
        Borders_SmoothLine = "RELATIVE PATH FOR THE OUTPUT DATA"
        with arcpy.EnvManager(transferGDBAttributeProperties=False):
            arcpy.cartography.SmoothLine(in_features=Borders_Original, out_feature_class=Borders_SmoothLine, algorithm="PAEK", tolerance="20000 Meters", endpoint_option="FIXED_CLOSED_ENDPOINT", error_option="FLAG_ERRORS", in_barriers=[])

        # Process: Align borders to rivers within threshold (Align Features) (edit)
        Borders_SmoothLine_Aligned = arcpy.edit.AlignFeatures(in_features=Borders_SmoothLine, target_features=Rivers_Poland_SmoothLine, search_distance="5000 Meters", match_fields=[])[0]

        # Process: Snap (Snap) (edit)
        Rivers_Poland_SmoothLine_2_ = arcpy.edit.Snap(in_features=Rivers_Poland_SmoothLine, snap_environment=[[Borders_SmoothLine_Aligned, "EDGE", "3 Kilometers"]])[0]

        # Process: Snap (2) (Snap) (edit)
        Water_snapped = arcpy.edit.Snap(in_features=Water_reservoirs, snap_environment=[[Rivers_Poland_SmoothLine_2_, "EDGE", "5000 Meters"]])[0]

        # Process: Select Layer By Attribute (Select Layer By Attribute) (management)
        Water_reservoirs_Layer, Count_8_ = arcpy.management.SelectLayerByAttribute(in_layer_or_view=Water_snapped, selection_type="NEW_SELECTION", where_clause="Shape_Area < 2000000000", invert_where_clause="")

        # Process: Feature To Point (Feature To Point) (management)
        Water_Point = "RELATIVE PATH FOR THE OUTPUT DATA"
        arcpy.management.FeatureToPoint(in_features=Water_reservoirs_Layer, out_feature_class=Water_Point, point_location="CENTROID")

        # Process: Select inland sea water reservoirs (Select Layer By Attribute) (management)
        Sea_water, Count_5_ = arcpy.management.SelectLayerByAttribute(in_layer_or_view=Water_3_, selection_type="NEW_SELECTION", where_clause="x_kod = 'PTWP01' And Shape_Area > 100000000 And Shape_Area < 500000000", invert_where_clause="")

        # Process: Copy Features (Copy Features) (management)
        Sea_water_copy = "RELATIVE PATH FOR THE OUTPUT DATA"
        arcpy.management.CopyFeatures(in_features=Sea_water, out_feature_class=Sea_water_copy, config_keyword="", spatial_grid_1=None, spatial_grid_2=None, spatial_grid_3=None)

        # Process: Aggregate Polygons (Aggregate Polygons) (cartography)
        Sea_water_dissolved = "RELATIVE PATH FOR THE OUTPUT DATA"
        Water_CopyFeatures_Aggregate_Tbl = "RELATIVE PATH FOR THE OUTPUT DATA"
        arcpy.cartography.AggregatePolygons(in_features=Sea_water_copy, out_feature_class=Sea_water_dissolved, aggregation_distance="500 Meters", minimum_area="0 SquareMeters", minimum_hole_size="0 SquareMeters", orthogonality_option="NON_ORTHOGONAL", barrier_features=[], out_table=Water_CopyFeatures_Aggregate_Tbl, aggregate_field="")

        # Process: Smooth Polygon (Smooth Polygon) (cartography)
        Sea_water_simplified = "RELATIVE PATH FOR THE OUTPUT DATA"
        with arcpy.EnvManager(transferGDBAttributeProperties=False):
            arcpy.cartography.SmoothPolygon(in_features=Sea_water_dissolved, out_feature_class=Sea_water_simplified, algorithm="PAEK", tolerance="20000 Meters", endpoint_option="FIXED_ENDPOINT", error_option="NO_CHECK", in_barriers=[])

        # Process: Snap_rivers_to_sea_water (Snap) (edit)
        Rivers_Poland_SmoothLine_3_ = arcpy.edit.Snap(in_features=Rivers_Poland_SmoothLine, snap_environment=[[Sea_water_simplified, "EDGE", "5000 Meters"]])[0]

        # Process: Polygon To Line (Polygon To Line) (management)
        Inland_seaWater_line = "RELATIVE PATH FOR THE OUTPUT DATA"
        arcpy.management.PolygonToLine(in_features=Sea_water_simplified, out_feature_class=Inland_seaWater_line, neighbor_option="IDENTIFY_NEIGHBORS")

if __name__ == '__main__':
    FinalPipeline()
